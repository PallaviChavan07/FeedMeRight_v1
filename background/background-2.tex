% Chaper background Continued .. 
\section{Recommender System}
Recommender systems are information filtering systems that provide a solution for the problem of information overload \cite{45}. The process involves filtering important information out of a large amount of data according to the user's preferences and interests. The recommender systems can predict item or product relevancy to the user based on the user's profile and preferences. The basic idea of the general recommender model is given in \autoref{fig:recommender_model} \\ which explains the interaction of users and items with the system. Dataset of items represents the description of items for instance recipes. Description of a recipe may contain information about different factors of recipes such as ingredients used in the recipe, cooking type, calories, cuisine type. User Modeling in the figure represents the user's preferences. Consider a user who likes Mexican recipes with low calories. The profile exploitation step matches the user's profile information with all recipes present in the data set. At this point, the recommendation algorithm gets applied to match the user profile and recipe profile. All Mexican dishes with low calories will get filtered out from the data set for our user. All filtered recipes hold some ranking based on the recommendation algorithm. Top- N recipes will get recommended to our user based on the ranking predicted by the recommendation algorithm. The user adopts those recommendations and responds to the results generated by the recommendation system by providing feedback. The system updates the user profile based on the feedback received by the system from a user. Recommendation systems correlate one user with a group of other users to find similar users. In this case, the system will match a user's profile with all other users who prefer Mexican low-calorie food. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{recommender_model}
	\caption{General Recommender Model \cite{3}}
	\label{fig:recommender_model}
\end{figure}

\noindent Based on recommendations generated by system may vary the interaction between users and items. For that reason, we need to understand the features of different recommendation techniques. \autoref{fig:recommender_techniques} shows broadly categorized recommendation techniques.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{recommender_techniques}
	\caption{Recommendation Techniques \cite{33}}
	\label{fig:recommender_techniques}
\end{figure}


\noindent As shown in \autoref{fig:recommender_techniques}, traditionally there are two basic models of recommender systems. \begin{itemize} \item Content Based Filtering \item Collaborative Filtering \item Hybrid Filtering \end{itemize}
In next section we will discuss commonly used methods.
\pagebreak

\subsection{Content Based Filtering}
In Content based method algorithm, user preference is considered based on item description. The rating and buying behavior of users are combined with content information available in the items. The main aim of content based filtering is to create a profile for each item as well as each user in order to find similar items that reflects a user's taste \cite{6}.
\\

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{contentbased_architecture}
	\caption{Content Based filtering Architecture \cite{5}}
	\label{fig:contentbased_architecture}
\end{figure}

\noindent 
The architecture of content based model highlights the process steps in \autoref{fig:contentbased_architecture}. 


\begin{itemize}
\item \textbf{Content Analyzer} 
\\
When information has no exact structure like a document that time pre-processing step is necessary to extract relevant features from that document. Content analyzer analyzes such items as recipes, documents, books, product descriptions to extract and present the content of items. Information source contains data in the raw format. Each data item coming from an information source is pre-processed and analyzed by feature extraction techniques to transform original information into a more structured format. The output of the content analyzer is the input for the profile learner and filtering component.

\item \textbf{Profile Learner} 
\\
Profile learner constructs a user profile by collecting user preference data. The generalization strategy is applied to the collected data using machine learning techniques. For example, the profile learner of a movie recommender can implement a relevance feedback method in which rating on a scale of 0 to 5 is considered. Rating value above 3 is considered as a positive rating implies likes for the movie and rating value below 3 considered as negative rating implies dislike for a movie. The learning technique combines liked and disliked movies by the user and the vector of positive and negative examples into a vector that represents user profile. 

\item \textbf{Filtering Component}
\\
Filtering component uses user's profile to find matching items from items data set. The items are matching with a user's data profile is decided by calculating similarity between a user's data profile and item vectors. A list of potential interesting items is recommended by filtering component. 
\end{itemize}
\noindent
In content based algorithm each user's information can be stored in vector form which contains past behavior of the user. This vector is known as profile vector or user profile. All the information about item is stored in item vector or item profile which contains all the details about item specific attributes. Based on similarity score between user profile and item profile most relevant items are recommended to user. The calculation of user or item vector is discussed in \autoref{vector_space_model}.

\subsubsection{Vector Space Model}
\label{vector_space_model}
Vector Space Model (VSM) for information retrieval represents documents as queries as vectors of weight \cite{46}. It is also known as term vector model as it uses term occurrences as vector identifier. 
\\
Each item profile and user profile can be represented in the form of vectors. For instance, consider example of users and books rating relationship based on ratings given by users to the books based on book's genre. The \autoref{book_genre} represents the book and it's genre relationship in binary form. 1 is considered as book shares that genre and 0 represents that book does not share the genre. Book1 is solely based on Machine Learning while book3 talks about Security and Databases. Here genre of book is an attribute or feature that is considered to represent a book in vector form. Rows in \autoref{book_genre} represents item vector for book1, book2 and book3 respectively.   

\begin{table}[]
\centering

\begin{tabular}{|l|l|l|l|}
\hline
      & Machine Learning & Databases & Cyber Security \\ \hline
book1 & 1                & 0         & 0              \\ \hline
book2 & 1                & 0         & 1              \\ \hline
book3 & 0                & 1         & 1              \\ \hline
\end{tabular}
\caption{Books in Vector Form}

\label{book_genre}
\end{table} 

\noindent
Similarly, a user profile can be represented in a vector form. Consider a user liked book1 and book3 where 1 represents like and 0 represents dislike as shown in \autoref{user_ratings_for_books}. 

\begin{table}[]
\centering
\begin{tabular}{|l|l|}
\hline
      & user ratings \\ \hline
book1 & 1            \\ \hline
book2 & 0            \\ \hline
book3 & 1            \\ \hline
\end{tabular}
\caption{User Rating for Books}
\label{user_ratings_for_books}
\end{table}

The simplest way to form a user vector is to take a sum of dot product of matrices as resulted in \autoref{book_user_vector}.  
\begin{table}[]
\begin{tabular}{|l|l|l|}
\hline
Machine Learning & Databases & Cyber Security \\ \hline
1                & 1         & 1              \\ \hline
\end{tabular}
\caption{User Vector for Book's Genres}
\label{book_user_vector}
\end{table}


\subsubsection{Advantages of content-based filtering}

Content-based recommender systems are heavily reliable on the contents of the items that have been rated by the user. So, while making recommendations, this approach would consider user’s taste and accordingly recommend an item that matches user’s preferences. Generally, most popular items dominate less popular items. But this approach will not miss less popular item if it matches the user’s unique taste \cite{6}.
\\
\subsubsection{Disadvantages of content-based filtering}

User profiles are generated based on rated items. But for any new user who has not rated any items yet, user profile will be empty. In that case, recommending perfect item that matches to user’s taste is difficult as system does not have user taste information. This problem is known as cold start. Also, to understand each items feature, system needs to examine content of every item. Therefore if number of items rises quickly, performance of the system decreases \cite{6}.  
\\

\subsection{Collaborative Filtering}
Collaborative filtering uses other users behavior in the system to predict and recommend items. It depends on user's contribution such as ratings, reviews which considered as filter for user preference information. The fundamental idea of collaborative filtering is, it selects other users opinions and aggregate in such way that it provides prediction for active user based on his preferences \cite{7}. 
\\The main source of input for this algorithm is in the form of matrix of collected user-item ratings. Based on this input it provides recommendations as an output. The first step of output is to predict ratings for items that user may like. Prediction is a numerical that represents predicted score of specific item for specific user. Second step is to recommend a list of top rated items as top-N items. \autoref{fig:collaborative_process} highlights the collaborative filtering process.
\\

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{collaborative_process}
	\caption{Collaborative Filtering Process \cite{33}}
	\label{fig:collaborative_process}
\end{figure}


\noindent Collaborative Filtering technique is broadly divided into 2 categories \cite{11}. 
\\
\begin{itemize}
\item Memory-based CF
\item Model-based CF
\end{itemize}

\subsubsection{A. Memory-Based (user based)}
A memory-based collaborative filtering approach predicts item ratings based on ratings given by different users for an item. There are primary two forms of memory-based collaborative filtering.
\paragraph{i. User-User CF:} 

Similarity between users is calculated based on how similarly they rate several items. It finds other users whose ratings are similar to active user and use their ratings on other items to predict what active user may like. Thus it recommends items to the users that are most preferred by similar users.
\\
Consider example of user and ratings given by users to different recipes. This algorithm will find similarity between each user based on the ratings they have given to the recipes in the past. The prediction of a recipe for a user u is calculated by computing weighted sum of the user ratings given by other users to recipe i.
The prediction for recipe I is given as below:
\\
\begin{equation}
P_{u,v} = \frac { \sum_v(r_{v,i} * S_{u,v})}{\sum_v S_{u,v}}
\end{equation}
\\
Where, 
\\
\noindent
$P_{u,i} = $ \text{prediction of recipe } $i$ 
\\
$R_{v,i} = $ \text{rating given by user} $v$ \text{ to recipe } $i$ 
\\
$S_{u,v} = $\text{similarity between users.} 
\\

\noindent To predict the ratings for other user we need to calculate similarity score. The similarity between users can be calculated with the help of several methods described in the section of \nameref{similarity_methods}. Prior to that we need to find items rated by both users and its rating. Based on that rating, if we opt to calculate similarities with the Pearson correlation then we will get correlation score between users. Higher correlation implied higher similarity. Recommendations are made based on these prediction values. 
\\
This algorithm is quite expensive in terms of time as it involves calculating similarity score between each user and from that score calculating predictions. 
\\
\noindent \paragraph{ii. Item-Item CF:}

Item-Item CF filtering are introduced to solve challenges in User-User CF. As we seen in user user CF may become so expensive if we have large number of users. If we have huge number of users that items then it is ideal to adopt item-based CF.
\\
\\
This algorithm calculates the similarity between items instead of users. It considers ratings of active user to make predictions for item $i$, as $i$ will be similar to the items rated in the past by active user. Therefore, user may prefer to use his own ratings than using some other users' ratings. It helps in maintaining user preferences and choice. The similarity between item can be calculated with any formula from section (add number) cosine similarity, Pearson
correlation,Jacquard or Eucidean's distance formula.
\\
The rating prediction for item-item collaborative filtering is calculated with below equation:
\begin{equation}
P_{u,i} = \frac { \sum_N(S_{i,N} * R_{u,N})}{\sum_N (\vert S_{i,N} \vert)}
\end{equation}
\\
Where, 
\\
\noindent
$P_{u,i} = $ \text{prediction of item $i$ for user } $u$ 
\\
$R_{u,N} = $ \text{rating given by user } $u$ \text{ on item } $N$ 
\\
$S_{i,N} = $\text{similarity between item $i$ and $N$.} 
\\
\\
Memory based collaborative filtering can be useful in any area where we don't need to select many features. At the same time it suffers from dome drawbacks \cite{10}.
\\
\\
\textbf{Sparsity:}
\\
Many large systems that uses recommender systems to recommend their products has huge number of products in their database. All products are not rated by users. In that case, ratio of actual number of items to number of rated items is very huge. Because of such huge sparsity accuracy of recommender may result in poor recommendations.
\\
\\
\textbf{Scalability:}
\\
Nearest neighbor algorithm requires high computations. It grows with number of users and number of items in the system. Any web-based system which has huge number o items and users (example Amazon.com) may suffer from high scalability.

\subsubsection{B. Model-Based (item based):}
In contrary to memory-based collaborative filtering, model-based algorithm take the data that has been already preprocessed where it is cleansed, filtered and transformed and generate learned model to make predictions. This algorithm calculates similarity between users or items by generating a model and analyzing their pattern to predict ratings on unseen items \cite{28,29,30} .
\\
Model-based collaborative filter has several techniques such as Slope one \cite{31}, Matrix Factorization (MF) and Singular Value Decomposition (SVD) \cite{28}. 

%based on SVD, SVD++, Matrix Factorization using gradient descent, Co-clusturing, Slope one approach.
In this section we will see frequently used model-based techniques.
\\

\paragraph{i. Singular Value Decomposition (SVD) }
SVD is a technique of matrix factorization which is used to reduce the number of features in the data set. The matrix factorization is done on the matrix which is generated by the user's feedback in the form of ratings on different items. In SVD, the technique is used to detect latent relationship between users and items. Then it generate a low dimensional representation of original matrix space to calculate neighborhood in the reduced space \cite{32}. The original ratings matrix decomposes by SVD in two matrices in such way that product of decomposed matrices is original rating matrix. The SVD is calculated as shown in \autoref{svd}

\begin{equation}
SVD(M) = U \times S \times V^{T} 
\label{svd}
\end{equation}
\noindent Where,\\
$SVD(M)$ denotes matrix M with dimensions $m \times n$ which are total number of users and items respectively.\\
Dimensions of matrix $U$ will be $m \times m$ \\
Dimensions of matrix $S$ will be $m \times r$ \\
Dimensions of matrix $V$ will be $r \times n$ \\
$U$ and $V$ are called left and right singular vectors. To reduce features of dataset one can keep only k highest values and eliminate lower entries. So, $(r-k)$ columns from $U$ and $(r-k)$ rows from $V^{T}$ are discarded to gnerate $U_{k}$ and $V_{k}^{T}$ matrices. Now $M_{k}$ can be constructed with multiplication of $U_{k}$ and $V_{k}$ together using $S_{k}$. Generated $M_{k}$ will closest rank $k$ matrix to $M$. Mathematically it can be represented as in \autoref{svd1}

\begin{equation}
M_{k} = U_{k} \times S_{k} \times V_{k}^{T} 
\label{svd1}
\end{equation}

\noindent Rating prediction for user $u$ for item $i$ is given in \autoref{svd2} \\

\begin{equation}
r_{ui} = r_{u} + U_{k} \sqrt{S_{k}^{T} (u)} \times \sqrt{S_k} \times V_{k}^{T}
\label{svd2}
\end{equation}

\noindent With SVD we can predict ratings with good accuracy.




\subsection{Hybrid Filtering}
Pure recommendation systems have some limitations. Hybrid filtering technique is a combination of different recommendation techniques to overcome limitations of pure recommendation techniques to improve performance \cite{37,38}. Many researchers have combined content-based and collaborative filtering techniques to gain better results. The idea behind combining difeerent recommendation techniques is that resultant algorithm will provide more accurate and effective recommendations than any single algorithm \cite{39}. Using mulitple techniques we can overcome weaknesses of single technique. Burk \cite{} has categorized hybrid techniques in different types. One of them is weighted Hybridization.\\

\subsubsection{Weighted Hybridization}
In this technique, the results of multiple algorithms are combined to generate predictions by integrating the scores of each algorithm used. For example, \cite{41} P-Tango system combines content-based and collaborative filtering techniques. At start, both techniques were equally weighted but based on performance and user ratings the weight for different techniques has gradually adjusted. In this paper, we will be using weighted hybrid technique.



